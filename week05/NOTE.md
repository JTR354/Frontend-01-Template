# 第5周学习记录
## [本周作业地址链接(手写一个httpRequest):](./http-toy)

## 摘要
本周最大收获,亲眼目睹`HTTP`的发送过程,和明白了传说中的`状态机`.

## 遇到的问题
1. 在写请求报文头部信息时,content-length设置的长度如何跟body里面的长度对应不上就会报错。  
后来仔细想了想，假如你报文头部的content-length中告诉服务器你要发送10个字节长度的内容，但实际发送的内容却是5个或12个,反正就是对应不上;那么服务器那边不就傻了,少了会死死苦等,多了要么切断要么就不知道如何处理了.  
我自己想了想应该就是这个原因,然后再研究下winter老师的翻车现场应该开始有几处就是这个原因吧?

2. 发现服务端响应头的响应体(因为是chunked类型)的每个chunked-size是16进制的数据;然后返回的中文字符占3/4个长度

3. 电脑从休眠中起来,必须要先杀掉之前的node进程不然发送的请求会发送到之前开着的服务器上去.

4. 想当然的认为可以简化状态机,当把收到的所有字符,然后判断最后几个字符是否是\r\n0\r\n\r\n，就判断是否已经接收数据完毕了，然后拿着完整的数据正则一把。    
后仔细想想，不行呀，body的内容可能不止chunked一种格式,不同格式终结的内容肯定也不一样,再加上body内容的形式要根据响应头中的字段进行确定,这种投机取巧的把戏只能是个把戏了.

`tips: windows node 终结进程命令`
```bash
- netstat -a -n  #各个端口占用
- netstat -ano   #各个端口占用和进程PID
- netstat -aon | findstr "8088" 
- tasklist | findstr "8088" 查看端口号所对应的应用程序
- taskkill /pid 4456 /F 终止进程
tasklist | findstr "8088" 
```



## 小结
状态机的精髓在于逻辑分割,每个状态处理每个状态的事情  
http没有那么可怕,你不理它,它不理你,盘它就是了  
实践出真知,代码里面全是细节和魔鬼  
学习了这么些日子,自己总有一种错觉,认为自己能够实现任何功能.